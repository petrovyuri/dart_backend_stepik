part of 'app_handlers.dart';

/// Обработчик HTTP-запроса для получения информации о текущем аутентифицированном пользователе.
///
/// Этот обработчик предназначен для защищенного эндпоинта, который возвращает данные
/// пользователя, идентифицированного по JWT токену из заголовка запроса.
Future<Response> _getUserHandler(Request request, DiContainer di) async {
  try {
    // ========================================================================
    // ШАГ 1: Извлечение userId из контекста запроса
    // ========================================================================
    // JWT middleware (jwt_middleware.dart) предварительно обрабатывает запрос:
    // - Извлекает JWT токен из заголовка Authorization
    // - Валидирует токен и извлекает из него userId
    // - Добавляет userId в контекст запроса под ключом 'user_id'
    //
    // Расширение RequestExt предоставляет удобный геттер request.userId
    // для доступа к этому значению из контекста.
    final userId = request.userId;

    // ========================================================================
    // ШАГ 2: Валидация наличия userId
    // ========================================================================
    // Если userId отсутствует, это означает одно из следующего:
    // - Токен не был передан в заголовке Authorization
    // - Токен имеет невалидный формат
    // - Токен истек или был отозван
    // - JWT middleware не смог обработать токен
    //
    // В этом случае возвращаем 401 Unauthorized с кодом ошибки,
    // указывающим на проблему с обработкой токена авторизации.
    if (userId == null) {
      di.logger.info('userId отсутствует в контексте запроса');
      return Response.unauthorized(
        await HandlerUtil.bodyToJson(
          message: 'userId отсутствует в контексте запроса',
          code: CodeAction.authorizationTokenProcessingError,
        ),
      );
    }

    // Логируем начало обработки запроса для отладки
    di.logger.debug('Получение информации о пользователе с ID: $userId');

    // ========================================================================
    // ШАГ 3: Загрузка данных пользователя из базы данных
    // ========================================================================
    // Используем UserService для получения полной информации о пользователе.
    // Метод getUserById выполняет SQL-запрос к таблице users и возвращает
    // объект User с полями: id, email (зашифрованный), password (хэшированный).
    //
    // Если пользователь не найден, метод вернет null.
    final user = await di.userService.getUserById(userId);

    // ========================================================================
    // ШАГ 4: Проверка существования пользователя
    // ========================================================================
    // Возможна ситуация, когда токен содержит валидный userId, но пользователь
    // был удален из базы данных после создания токена. В этом случае
    // возвращаем 404 Not Found с соответствующим сообщением.
    if (user == null) {
      di.logger.info('Пользователь с ID $userId не найден');
      return Response.notFound(
        await HandlerUtil.bodyToJson(message: 'Пользователь не найден', code: CodeAction.userNotFoundById),
      );
    }

    // ========================================================================
    // ШАГ 5: Расшифровка email пользователя
    // ========================================================================
    // В базе данных email хранится в зашифрованном виде для защиты персональных данных.
    // Перед отправкой клиенту необходимо расшифровать email с помощью CryptoService.
    //
    // Важно: пароль НЕ расшифровывается, так как он хранится в виде хэша
    // (односторонняя функция) и не может быть восстановлен.
    final decryptedEmail = di.cryptoService.decryptData(user.email);

    // ========================================================================
    // ШАГ 6: Формирование ответа клиенту
    // ========================================================================
    // Создаем JSON-объект с информацией о пользователе.
    // В ответе возвращаем только безопасные данные:
    // - id: идентификатор пользователя
    // - email: расшифрованный email адрес
    //
    // Пароль НЕ включается в ответ по соображениям безопасности.
    final responseBody = jsonEncode({'id': user.id, 'email': decryptedEmail});

    // Логируем успешное завершение операции
    di.logger.debug('Информация о пользователе успешно получена');

    // Возвращаем успешный HTTP-ответ со статусом 200 OK
    return Response.ok(responseBody);
  } on Object catch (e, stackTrace) {
    // ========================================================================
    // ОБРАБОТКА НЕПРЕДВИДЕННЫХ ОШИБОК
    // ========================================================================
    // Перехватываем любые исключения, которые могут возникнуть в процессе:
    // - Ошибки подключения к базе данных
    // - Ошибки расшифровки данных (некорректный ключ, поврежденные данные)
    // - Ошибки сериализации JSON
    // - Любые другие непредвиденные ошибки
    //
    // Логируем полную информацию об ошибке (сообщение, исключение, стек вызовов)
    // для последующего анализа и отладки.
    //
    // Возвращаем клиенту общий ответ 500 Internal Server Error, чтобы не раскрывать
    // детали внутренней реализации системы.
    di.logger.error('Ошибка при получении информации о пользователе: $e', e, stackTrace);
    return Response.internalServerError(
      body: await HandlerUtil.bodyToJson(
        message: 'Ошибка при получении информации о пользователе',
        code: CodeAction.parseErrorInUserRequest,
      ),
    );
  }
}
